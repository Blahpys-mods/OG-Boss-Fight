;;-*-Lisp-*-
(in-package goal)

;; This file will define attacks to be used by the boss

;; ##########################################################
;; ##########################################################
;; ##########################################################
;; ATTACK-DARK ##############################################
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; attack-dark is a heavily modified copy of caveflamepots from maincave-obs.gc
;; It is the attack type that covers an entire dark square.

(deftype attack-dark (process-drawable)
  (
    (cshape             collide-shape :overlay-at root)
    (shove-up            float)
    (cycle-speed         int32)
    (cycle-pause         int32)
    (cycle-offset        uint32)
    (was-deadly?         symbol)
    (should-play-sound?  symbol)
    (launch-pos          vector         2 :inline)
  )
  (:states
    attack-dark-active
    attack-dark-inactive
  )
)

(defstate attack-dark-active (attack-dark)
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (current-time) (the-as time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         ;;(when (sphere-in-view-frustum? (the-as sphere (-> self cshape root-prim prim-core))) ;; I've disabled this so that the particles still appear when you look up
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 112))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 224))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 336))) 
          (let (
            (trans-x-lo (- (-> self root trans x) (meters 10.0))) ;; coordinates aligning with the corners of the square
            (trans-x-hi (+ (-> self root trans x) (meters 10.0)))
            (trans-z-lo (- (-> self root trans z) (meters 10.0)))
            (trans-z-hi (+ (-> self root trans z) (meters 10.0))))
            (if (and (> (-> *target* root trans x) trans-x-lo) (< (-> *target* root trans x) trans-x-hi) (> (-> *target* root trans z) trans-z-lo) (< (-> *target* root trans z) trans-z-hi))
              (send-event *target* 'attack #t (new 'static 'attack-info :mask #xe0 :shove-up (meters 10) :shove-back (meters 10) :mode 'burn))
            )
          )
           ;;) end paren for when above
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame")
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self cshape))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self cshape))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self cshape))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self cshape))
            )
          )
        )
      )
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    )
  )

(defstate attack-dark-inactive (attack-dark) ;; do literally nothing if inactive
  :enter (behavior ()
    
  )
  :exit (behavior ()
    
  )
  :trans (behavior ()
    
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defmethod init-from-entity! attack-dark ((this attack-dark) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 81920.0))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 8192.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0)
    )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  ;;(initialize-skeleton this *attack-dark-sg* '())
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> this cshape quat) (-> this cshape quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> this cshape quat))))
    (let ((s4-1 (-> this launch-pos))) ;; We launch particles from four locations in an attempt to telegraph that the attack hitbox is square.
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) (meters -5.0))
        (set! (-> v1-53 0 y) (meters 3))
        (set! (-> v1-53 0 z) (meters -5.0))
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the-as vector s4-1) (the-as vector s4-1) f30-0)
      (vector+! (the-as vector s4-1) (the-as vector s4-1) (-> this root trans))
      )
    (let ((s4-2 (the-as object (&-> this stack 112)))) ;; Second particle launch position
      (set-vector! (the-as vector s4-2) (meters 5.0) (meters 3) (meters -5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2) (the-as vector s4-2) f30-0)
      (vector+! (the-as vector s4-2) (the-as vector s4-2) (-> this root trans))
      )
    (let ((s4-2-2 (the-as object (&-> this stack 224)))) ;; Third particle launch position
      (set-vector! (the-as vector s4-2-2) (meters -5.0) (meters 3) (meters 5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2-2) (the-as vector s4-2-2) f30-0)
      (vector+! (the-as vector s4-2-2) (the-as vector s4-2-2) (-> this root trans))
      )
    (let ((s4-2-3 (the-as object (&-> this stack 336)))) ;; Fourth particle launch position
      (set-vector! (the-as vector s4-2-3) (meters 5.0) (meters 3) (meters 5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2-3) (the-as vector s4-2-3) f30-0)
      (vector+! (the-as vector s4-2-3) (the-as vector s4-2-3) (-> this root trans))
      )
    (let ((s4-3 (-> this cshape root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> this cshape))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the-as int (-> sv-16 elt-count)) 0))
                                                        (-> v1-70 0)
                                                        4.0
                                                        )
                                              )
                                       )
            )
      )
    )
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the-as uint (the int (* f30-2 (if (and v1-74 (< 1 (the-as int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the-as int (-> sv-48 elt-count))))
                                                        (-> v1-77 2)
                                                        2.0
                                                        )
                                              )
                                       )
            )
      )
    )
  (go attack-dark-inactive)
  (none)
  )

  ;;This function should attack every dark square at once
  (defun attack-all-dark-squares ()
    (go-process (process-by-ename "boss1-attack-dark-1-1") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-1-3") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-1-5") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-2-2") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-2-4") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-2-6") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-3-1") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-3-3") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-3-5") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-4-2") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-4-4") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-4-6") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-5-1") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-5-3") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-5-5") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-6-2") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-6-4") attack-dark-active)
    (go-process (process-by-ename "boss1-attack-dark-6-6") attack-dark-active)
  )

  (defun stop-attack-all-dark-squares ()
    (go-process (process-by-ename "boss1-attack-dark-1-1") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-1-3") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-1-5") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-2-2") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-2-4") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-2-6") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-3-1") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-3-3") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-3-5") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-4-2") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-4-4") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-4-6") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-5-1") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-5-3") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-5-5") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-6-2") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-6-4") attack-dark-inactive)
    (go-process (process-by-ename "boss1-attack-dark-6-6") attack-dark-inactive)
  )
  
#|
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; ATTACK-LIGHT #############################################
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; attack-light is a heavily modified copy of caveflamepots from maincave-obs.gc
;; It is the attack type that covers an entire light square.

(deftype attack-light (process-drawable)
  (
    (cshape             collide-shape :overlay-at root)
    (shove-up            float)
    (cycle-speed         int32)
    (cycle-pause         int32)
    (cycle-offset        uint32)
    (was-deadly?         symbol)
    (should-play-sound?  symbol)
    (launch-pos          vector         2 :inline)
  )
  (:states
    attack-light-active
    attack-light-inactive
  )
)

(defstate attack-light-active (attack-light)
  :trans (behavior ()
    (let* ((v1-0 (-> self cycle-speed))
           (a0-1 (- v1-0 (-> self cycle-pause)))
           (gp-0 (mod (+ (current-time) (the-as time-frame (-> self cycle-offset))) v1-0))
           )
      (cond
        ((< gp-0 a0-1)
         ;;(when (sphere-in-view-frustum? (the-as sphere (-> self cshape root-prim prim-core))) ;; I've disabled this so that the particles still appear when you look up
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 112))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 224))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (&-> self stack 336))) 
          (let (
            (trans-x-lo (- (-> self root trans x) (meters 10.0))) ;; coordinates aligning with the corners of the square
            (trans-x-hi (+ (-> self root trans x) (meters 10.0)))
            (trans-z-lo (- (-> self root trans z) (meters 10.0)))
            (trans-z-hi (+ (-> self root trans z) (meters 10.0))))
            (if (and (> (-> *target* root trans x) trans-x-lo) (< (-> *target* root trans x) trans-x-hi) (> (-> *target* root trans z) trans-z-lo) (< (-> *target* root trans z) trans-z-hi))
              (send-event *target* 'attack #t (new 'static 'attack-info :mask #xe0 :shove-up (meters 10) :shove-back (meters 10) :mode 'burn))
            )
          )
           ;;) end paren for when above
         (when (-> self should-play-sound?)
           (set! (-> self should-play-sound?) #f)
           (sound-play "hot-flame")
           )
         (cond
           ((< gp-0 30)
            (when (-> self was-deadly?)
              (set! (-> self was-deadly?) #f)
              (clear-collide-with-as (-> self cshape))
              )
            )
           (else
             (when (not (-> self was-deadly?))
               (set! (-> self was-deadly?) #t)
               (restore-collide-with-as (-> self cshape))
               )
             )
           )
         (when (and (not (-> self was-deadly?)) (< 60 gp-0))
           (set! (-> self was-deadly?) #t)
           (restore-collide-with-as (-> self cshape))
           )
         )
        (else
          (set! (-> self should-play-sound?) #t)
          (when (-> self was-deadly?)
            (set! (-> self was-deadly?) #f)
            (clear-collide-with-as (-> self cshape))
            )
          )
        )
      )
    )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      )
    )
  )

(defstate attack-light-inactive (attack-light) ;; do literally nothing if inactive
  :enter (behavior ()
    
  )
  :exit (behavior ()
    
  )
  :trans (behavior ()
    
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defmethod init-from-entity! attack-light ((this attack-light) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 81920.0))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 8192.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0)
    )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  ;;(initialize-skeleton this *attack-light-sg* '())
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
        (go process-drawable-art-error "no path")
        )
    )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
        (quaternion-rotate-y! (-> this cshape quat) (-> this cshape quat) f0-23)
        )
    )
  (let ((f30-0 (quaternion-y-angle (-> this cshape quat))))
    (let ((s4-1 (-> this launch-pos))) ;; We launch particles from four locations in an attempt to telegraph that the attack hitbox is square.
      (let ((v1-53 s4-1))
        (set! (-> v1-53 0 x) (meters -5.0))
        (set! (-> v1-53 0 y) (meters 3))
        (set! (-> v1-53 0 z) (meters -5.0))
        (set! (-> v1-53 0 w) 1.0)
        )
      (vector-rotate-around-y! (the-as vector s4-1) (the-as vector s4-1) f30-0)
      (vector+! (the-as vector s4-1) (the-as vector s4-1) (-> this root trans))
      )
    (let ((s4-2 (the-as object (&-> this stack 112)))) ;; Second particle launch position
      (set-vector! (the-as vector s4-2) (meters 5.0) (meters 3) (meters -5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2) (the-as vector s4-2) f30-0)
      (vector+! (the-as vector s4-2) (the-as vector s4-2) (-> this root trans))
      )
    (let ((s4-2-2 (the-as object (&-> this stack 224)))) ;; Third particle launch position
      (set-vector! (the-as vector s4-2-2) (meters -5.0) (meters 3) (meters 5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2-2) (the-as vector s4-2-2) f30-0)
      (vector+! (the-as vector s4-2-2) (the-as vector s4-2-2) (-> this root trans))
      )
    (let ((s4-2-3 (the-as object (&-> this stack 336)))) ;; Fourth particle launch position
      (set-vector! (the-as vector s4-2-3) (meters 5.0) (meters 3) (meters 5.0) 1.0)
      (vector-rotate-around-y! (the-as vector s4-2-3) (the-as vector s4-2-3) f30-0)
      (vector+! (the-as vector s4-2-3) (the-as vector s4-2-3) (-> this root trans))
      )
    (let ((s4-3 (-> this cshape root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
          )
        )
      )
    )
  (update-transforms! (-> this cshape))
  (let ((f30-1 300.0))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-70 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-16))))
      (set! (-> this cycle-speed) (the int (* f30-1 (if (and v1-70 (> (the-as int (-> sv-16 elt-count)) 0))
                                                        (-> v1-70 0)
                                                        4.0
                                                        )
                                              )
                                       )
            )
      )
    )
  (let ((f30-2 (the float (-> this cycle-speed))))
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-74 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-32))))
      (set! (-> this cycle-offset)
            (the-as uint (the int (* f30-2 (if (and v1-74 (< 1 (the-as int (-> sv-32 elt-count))))
                                               (-> v1-74 1)
                                               0.0
                                               )
                                     )
                              )
                    )
            )
      )
    )
  (let ((f30-3 300.0))
    (set! sv-48 (new 'static 'res-tag))
    (let ((v1-77 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (& sv-48))))
      (set! (-> this cycle-pause) (the int (* f30-3 (if (and v1-77 (< 2 (the-as int (-> sv-48 elt-count))))
                                                        (-> v1-77 2)
                                                        2.0
                                                        )
                                              )
                                       )
            )
      )
    )
  (go attack-light-inactive)
  (none)
  )

  ;;This function should attack every light square at once
  (defun attack-all-light-squares ()
    (go-process (process-by-ename "boss1-attack-light-1-1") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-1-3") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-1-5") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-2-2") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-2-4") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-2-6") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-3-1") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-3-3") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-3-5") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-4-2") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-4-4") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-4-6") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-5-1") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-5-3") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-5-5") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-6-2") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-6-4") attack-light-active)
    (go-process (process-by-ename "boss1-attack-light-6-6") attack-light-active)
  )

  (defun stop-attack-all-light-squares ()
    (go-process (process-by-ename "boss1-attack-light-1-1") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-1-3") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-1-5") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-2-2") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-2-4") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-2-6") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-3-1") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-3-3") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-3-5") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-4-2") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-4-4") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-4-6") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-5-1") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-5-3") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-5-5") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-6-2") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-6-4") attack-light-inactive)
    (go-process (process-by-ename "boss1-attack-light-6-6") attack-light-inactive)
  )|#