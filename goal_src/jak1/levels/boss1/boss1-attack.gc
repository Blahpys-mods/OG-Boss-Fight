;;-*-Lisp-*-
(in-package goal)

;; This file will define attacks to be used by the boss

;; ##########################################################
;; ##########################################################
;; ##########################################################
;; ATTACK-SQUARE ############################################
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; attack-square is a heavily modified copy of caveflamepots from maincave-obs.gc
;; It is the attack type that covers an entire square.

(defstate attack-square-active (attack-square)
  :trans (behavior ()
    ;;(when (sphere-in-view-frustum? (the-as sphere (-> self cshape root-prim prim-core))) ;; I've disabled this so that the particles still appear when you look up
    (if (-> (the boss1-control (process-by-ename "boss1-control-1")) attack-colour-override-chess?)
      (begin ;; chess mechanic particles
        (launch-particles (-> *part-id-table* 500112) (the-as vector (-> self launch-pos))) 
        (launch-particles (-> *part-id-table* 500112) (the-as vector (-> self launch-pos-2))) 
        (launch-particles (-> *part-id-table* 500112) (the-as vector (-> self launch-pos-3))) 
        (launch-particles (-> *part-id-table* 500112) (the-as vector (-> self launch-pos-4)))
      )
      (if (-> (the boss1-control (process-by-ename "boss1-control-1")) current-attack-element-dark?)
        (begin ;; dark particles
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos-2))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos-3))) 
          (launch-particles (-> *part-id-table* 500101) (the-as vector (-> self launch-pos-4))) 
        )
        (begin ;; light particles
          (launch-particles (-> *part-id-table* 500102) (the-as vector (-> self launch-pos))) 
          (launch-particles (-> *part-id-table* 500102) (the-as vector (-> self launch-pos-2))) 
          (launch-particles (-> *part-id-table* 500102) (the-as vector (-> self launch-pos-3))) 
          (launch-particles (-> *part-id-table* 500102) (the-as vector (-> self launch-pos-4))) 
        )
      )
    )
    
    (let (
      (trans-x-lo (- (-> self root trans x) (meters 10.0))) ;; coordinates aligning with the corners of the square
      (trans-x-hi (+ (-> self root trans x) (meters 10.0)))
      (trans-z-lo (- (-> self root trans z) (meters 10.0)))
      (trans-z-hi (+ (-> self root trans z) (meters 10.0))))
      (if (and (> (-> *target* root trans x) trans-x-lo) (< (-> *target* root trans x) trans-x-hi) (> (-> *target* root trans z) trans-z-lo) (< (-> *target* root trans z) trans-z-hi))
        (send-event *target* 'attack #t (new 'static 'attack-info :mask #xe0 :shove-up (meters 10) :shove-back (meters 10) :mode 'burn))
      )
    )
     ;;) end paren for when above
    (when (-> self should-play-sound?)
      (set! (-> self should-play-sound?) #f)
      (sound-play "hot-flame")
    )
    (when (-> self was-deadly?)
      (set! (-> self was-deadly?) #f)
      (clear-collide-with-as (-> self cshape))
    )
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defstate attack-square-inactive (attack-square) ;; do literally nothing if inactive
  :enter (behavior ()
    
  )
  :exit (behavior ()
    
  )
  :trans (behavior ()
    
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defmethod init-from-entity! attack-square ((this attack-square) (arg0 entity-actor))
  ;;(local-vars (sv-16 res-tag) (sv-32 res-tag) (sv-48 res-tag))
  (set! (-> this was-deadly?) #f)
  (set! (-> this should-play-sound?) #f)
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 81920.0))
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 8192.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0)
    )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0)
  )
  (process-drawable-from-entity! this arg0)
  ;;(initialize-skeleton this *attack-square-sg* '())
  (let ((v1-42 (new 'process 'path-control this 'path 0.0)))
    (set! (-> this path) v1-42)
    (logior! (-> v1-42 flags) (path-control-flag display draw-line draw-point draw-text))
    (if (<= (-> v1-42 curve num-cverts) 0)
      (go process-drawable-art-error "no path")
    )
  )
  (let ((f0-23 (res-lump-float arg0 'rotoffset)))
    (if (!= f0-23 0.0)
      (quaternion-rotate-y! (-> this cshape quat) (-> this cshape quat) f0-23)
    )
  )
  (let ((f30-0 (quaternion-y-angle (-> this cshape quat))))
    (let ((s4-1 (-> this launch-pos))) ;; We launch particles from four locations in an attempt to telegraph that the attack hitbox is square.
      (set-vector! s4-1 (meters -5.0) (meters 3) (meters -5.0) 1.0)
      (vector+! s4-1 s4-1 (-> this root trans))
    )
    (let ((s4-2 (-> this launch-pos-2))) ;; Second particle launch position
      (set-vector! s4-2 (meters 5.0) (meters 3) (meters -5.0) 1.0)
      (vector+! s4-2 s4-2 (-> this root trans))
    )
    (let ((s4-2-2 (-> this launch-pos-3))) ;; Third particle launch position
      (set-vector! s4-2-2 (meters -5.0) (meters 3) (meters 5.0) 1.0)
      (vector+! s4-2-2 s4-2-2 (-> this root trans))
    )
    (let ((s4-2-3 (-> this launch-pos-4))) ;; Fourth particle launch position
      (set-vector! s4-2-3 (meters 5.0) (meters 3) (meters 5.0) 1.0)
      (vector+! s4-2-3 s4-2-3 (-> this root trans))
    )
    #|(let ((s4-3 (-> this cshape root-prim)))
      (dotimes (s3-1 (-> (the-as collide-shape-prim-group s4-3) num-prims))
        (let ((a1-19 (-> (the-as collide-shape-prim-group s4-3) prims s3-1 local-sphere)))
          (vector-rotate-around-y! a1-19 a1-19 f30-0)
        )
      )
    )|#
  )
  (update-transforms! (-> this cshape))
  
  (go attack-square-inactive)
  (none)
)

;;This function should attack every dark square at once
(defun attack-all-dark-squares ()
  (set! (-> (the boss1-control (process-by-ename "boss1-control-1")) current-attack-element-dark?) #t)
  (let ((aid (the uint 100300)))
    (dotimes (i 6)
      (begin
        (dotimes (j 6)
          (begin
            (1+! aid)
            (if (= (logand (+ i j) 1) 0)
              (go-process (process-by-aid aid) attack-square-active)
              #|  DEBUG VERSION BELOW
              (begin
                (format 0 "DEBUG: ~D~%" aid)
                (if (and (process-by-aid aid) (type-type? (-> (process-by-aid aid) type) attack-square))
                  (begin
                    (format 0 "DEBUG: ~D~%" aid)
                    (go-process (process-by-aid aid) attack-square-active)
                  )
                  (if (not (process-by-aid aid))
                    (format 0 "actor doesn't exist: ~D~%" aid)
                    (if (not (type-type? (-> (process-by-aid aid) type) attack-square))
                      (format 0 "type is not attack-square for actor: ~D~%" aid)
                    )
                  )
                  ;;(go-process (process-by-aid aid) attack-square-active)
                )
              )|#
            )
          )
        )
      )
    )
  )
)

(defun stop-attack-all-dark-squares ()
  (let ((aid (the uint 100300)))
    (dotimes (i 6)
      (begin
        (dotimes (j 6)
          (begin
            (1+! aid)
            (if (= (logand (+ i j) 1) 0)
              (go-process (process-by-aid aid) attack-square-inactive)
            )
          )
        )
      )
    )
  )
)

  ;;This function should attack every light square at once
(defun attack-all-light-squares ()
  (set! (-> (the boss1-control (process-by-ename "boss1-control-1")) current-attack-element-dark?) #f)
  (let ((aid (the uint 100300)))
    (dotimes (i 6)
      (begin
        (dotimes (j 6)
          (begin
            (1+! aid)
            (if (= (logand (+ i j) 1) 1)
              (go-process (process-by-aid aid) attack-square-active)
            )
          )
        )
      )
    )
  )
)

(defun stop-attack-all-light-squares ()
  (let ((aid (the uint 100300)))
    (dotimes (i 6)
      (begin
        (dotimes (j 6)
          (begin
            (1+! aid)
            (if (= (logand (+ i j) 1) 1)
              (go-process (process-by-aid aid) attack-square-inactive)
            )
          )
        )
      )
    )
  )
)

;; ##########################################################
;; ##########################################################
;; ##########################################################
;; ECO-ORB ##################################################
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; eco-orb is a glowing orb which is deactivated by touching it with the corresponding eco colour.
;; If left active for too long, it will explode.

(defstate eco-orb-inactive (eco-orb) ;; do literally nothing if inactive
  :enter (behavior ()
    
  )
  :exit (behavior ()
    
  )
  :trans (behavior ()
    
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defstate eco-orb-active (eco-orb)
  :trans (behavior ()
    (let (
      (trans-x-lo (- (-> self root trans x) (meters 10.0))) ;; coordinates aligning with the corners of the square
      (trans-x-hi (+ (-> self root trans x) (meters 10.0)))
      (trans-z-lo (- (-> self root trans z) (meters 10.0)))
      (trans-z-hi (+ (-> self root trans z) (meters 10.0)))
      (eco-type-1 (-> self eco-type))
      )
      #|(let (
        (particle-id-orbs (+ (-> self eco-type) 500102))
        )
        (launch-particles (-> *part-id-table* particle-id-orbs) (the-as vector (-> self root trans)))
      )|#
      (if (-> self orb-engorged?)
        (case (-> self eco-type)
          ((1)
            (launch-particles (-> *part-id-table* 500106) (the-as vector (-> self root trans)))
          )
          ((2)
            (launch-particles (-> *part-id-table* 500107) (the-as vector (-> self root trans)))
          )
          ((3)
            (launch-particles (-> *part-id-table* 500108) (the-as vector (-> self root trans)))
          )
        )
        (case (-> self eco-type)
          ((1)
            (launch-particles (-> *part-id-table* 500103) (the-as vector (-> self root trans)))
            ;;(launch-particles :system *sp-particle-system-3d* (-> *part-id-table* 500103) (the-as vector (-> self root trans)))
          )
          ((2)
            (launch-particles (-> *part-id-table* 500104) (the-as vector (-> self root trans)))
          )
          ((3)
            (launch-particles (-> *part-id-table* 500105) (the-as vector (-> self root trans)))
          )
        )
      )
      
      (if (and (> (-> *target* root trans x) trans-x-lo) (< (-> *target* root trans x) trans-x-hi) (> (-> *target* root trans z) trans-z-lo) (< (-> *target* root trans z) trans-z-hi))
        (if (or (and (send-event *target* 'query 'powerup (pickup-type eco-yellow)) (= eco-type-1 1)) (and (send-event *target* 'query 'powerup (pickup-type eco-red)) (= eco-type-1 2)) (and (send-event *target* 'query 'powerup (pickup-type eco-blue)) (= eco-type-1 3)))
          (begin
            (set! (-> self orb-sated?) #t)
            (go-process self eco-orb-inactive)
            ;; If the eco type the player has matches the orb
          )
          (send-event *target* 'attack #t (new 'static 'attack-info :mask #xe0 :shove-up (meters 10) :shove-back (meters 10) :mode 'burn)) ;; Otherwise it does damage
        )
      )
    )
    (when (-> self should-play-sound?)
      (set! (-> self should-play-sound?) #f)
      (sound-play "hot-flame")
    )
    (when (-> self was-deadly?)
      (set! (-> self was-deadly?) #f)
      (clear-collide-with-as (-> self cshape))
    )
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defstate eco-orb-exploding (eco-orb)
  :trans (behavior ()
    (send-event *target* 'attack #t (new 'static 'attack-info :mask #xe0 :mode 'melt))
    (case (-> self eco-type)
      ((1)
        (launch-particles (-> *part-id-table* 500109) (the-as vector (-> self root trans)))
      )
      ((2)
        (launch-particles (-> *part-id-table* 500110) (the-as vector (-> self root trans)))
        )
      ((3)
        (launch-particles (-> *part-id-table* 500111) (the-as vector (-> self root trans)))
      )
    )

    (when (-> self should-play-sound?)
      (set! (-> self should-play-sound?) #f)
      (sound-play "explod-bomb")
    )
    (when (-> self was-deadly?)
      (set! (-> self was-deadly?) #f)
      (clear-collide-with-as (-> self cshape))
    )
    ;; (go eco-orb-inactive)
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defmethod init-from-entity! eco-orb ((this eco-orb) (arg0 entity-actor))
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 81920.0))
  (set! (-> this eco-type) 0)
  (set! (-> this orb-engorged?) #f)
  (set! (-> this orb-sated?) #t)
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 8192.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0)
    )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0)
  )
  (process-drawable-from-entity! this arg0)  
  (go eco-orb-inactive)
  (none)
)

(defun start-orbs ()
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-01")) orb-sated?) #f)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-02")) orb-sated?) #f)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-03")) orb-sated?) #f)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-04")) orb-sated?) #f)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-01")) eco-type) (rand-vu-int-range 1 3))
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-02")) eco-type) (rand-vu-int-range 1 3))
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-03")) eco-type) (rand-vu-int-range 1 3))
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-04")) eco-type) (rand-vu-int-range 1 3))
  (go-process (process-by-ename "boss1-eco-orb-01") eco-orb-active)
  (go-process (process-by-ename "boss1-eco-orb-02") eco-orb-active)
  (go-process (process-by-ename "boss1-eco-orb-03") eco-orb-active)
  (go-process (process-by-ename "boss1-eco-orb-04") eco-orb-active)
)

(defun engorge-orbs ()
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-01")) orb-engorged?) #t)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-02")) orb-engorged?) #t)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-03")) orb-engorged?) #t)
  (set! (-> (the eco-orb (process-by-ename "boss1-eco-orb-04")) orb-engorged?) #t)
)

(defun explode-orbs ()
  (if (not (-> (the eco-orb (process-by-ename "boss1-eco-orb-01")) orb-sated?))
    (go-process (process-by-ename "boss1-eco-orb-01") eco-orb-exploding)
  )
  (if (not (-> (the eco-orb (process-by-ename "boss1-eco-orb-02")) orb-sated?))
    (go-process (process-by-ename "boss1-eco-orb-02") eco-orb-exploding)
  )
  (if (not (-> (the eco-orb (process-by-ename "boss1-eco-orb-03")) orb-sated?))
    (go-process (process-by-ename "boss1-eco-orb-03") eco-orb-exploding)
  )
  (if (not (-> (the eco-orb (process-by-ename "boss1-eco-orb-04")) orb-sated?))
    (go-process (process-by-ename "boss1-eco-orb-04") eco-orb-exploding)
  )
)

;; ##########################################################
;; ##########################################################
;; ##########################################################
;; CHESS-PIECE ##############################################
;; ##########################################################
;; ##########################################################
;; ##########################################################
;; chess-piece is a chess piece which will appear on the arena.
;; It will cause the square that the chess piece is on, and any square that it could attack in chess, to explode after some time.

(defstate chess-piece-inactive (chess-piece) ;; do literally nothing if inactive
  :enter (behavior ()
    
  )
  :exit (behavior ()
    
  )
  :trans (behavior ()
    
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defstate chess-piece-attacking (chess-piece)
  :trans (behavior ()
    (case (-> self piece-type)
      ((0) ;; null
        (format 0 "Something went wrong! Chess piece type is 0")
      )
      ((1) ;; knight
        
      )
      ((2) ;; bishop
        
      )
      ((3) ;; rook
        (let ((col-idx (- (-> (the boss1-control (process-by-ename "boss1-control-1")) chess-piece-col) 1)) (row-idx (- (-> (the boss1-control (process-by-ename "boss1-control-1")) chess-piece-row) 1)))
          (dotimes (i 6)
            (begin
              (if (not (= i row-idx))
                (begin
                  (format 0 "~D~%" (the uint (+ 100300 col-idx (* 6 i) 1)))
                  (go-process (process-by-aid (the uint (+ 100300 col-idx (* 6 i) 1))) attack-square-active)
                )
                ;;
              )
            )
          )
          (dotimes (i 6)
            (begin
              (if (not (= i col-idx))
                (begin
                  (format 0 "~D~%" (the uint (+ 100300 i (* 6 row-idx) 1)))
                  (go-process (process-by-aid (the uint (+ 100300 i (* 6 row-idx) 1))) attack-square-active)
                )
                ;;
              )
            )
          )
        )       
      )
      ((4) ;; queen

      )
    )

    #|(when (-> self should-play-sound?)
      (set! (-> self should-play-sound?) #f)
      (sound-play "explod-bomb")
    )
    (when (-> self was-deadly?)
      (set! (-> self was-deadly?) #f)
      (clear-collide-with-as (-> self cshape))
    )|#
  )
  :code (behavior ()
    (loop
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
    )
  )
)

(defmethod init-from-entity! chess-piece ((this chess-piece) (arg0 entity-actor))
  (set! (-> this shove-up) (res-lump-float arg0 'shove :default 81920.0))
  (set! (-> this piece-type) 0)
  (logclear! (-> this mask) (process-mask enemy))
  (logclear! (-> this mask) (process-mask attackable))
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s3-0 prim-core collide-as) (collide-kind enemy))
      (set! (-> s3-0 collide-with) (collide-kind target))
      (set! (-> s3-0 prim-core offense) (collide-offense no-offense))
      (set-vector! (-> s3-0 local-sphere) 0.0 8192.0 0.0 40960.0)
      (set-root-prim! s4-0 s3-0)
    )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (backup-collide-with-as s4-0)
    (set! (-> this cshape) s4-0)
  )
  (process-drawable-from-entity! this arg0)  
  (go chess-piece-inactive)
  (none)
)